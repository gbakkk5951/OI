对于100w以内的数据我们可以考虑O（n）递推
dp[i]表示i的
如果i为奇数 dp[i]=dp[i-1]//;因为在且只能在前一个数的每种方案前加2^0能够构成
如果i为偶数 dp[i]=dp[i-1]+dp[i/2];//dp[i-1]表示从dp[i-1]前加1个2^0组成；
//dp[i/2]表示在将dp[i/2]的每个加数*2(不以2^0开头)；
 
但对于本题来说 线性算法太萎了
我们需要log的几次方的时间复杂度和空间复杂度；

我们用dp[i][j][k]表示以2^i 开头 2^k 结尾 和为 2^j 的方案数；
显然,dp[i][i][i]=1；
转移通过枚举大小为2^(j-1)的所有dp[i][j-1][l]*dp[m][j-1][k] ， 求和得到，
其中 l >= i && l <=k ; m>=l && m <=k ;
由于当l > j-1 时 方案数为 0 所以乘积为0 可以不做考虑；

预处理出来dp数组之后
我们需要用dfs来枚举组合方案；
我们每次都要删掉剩余数最低一位的1；
枚举用哪一个dp来删掉,然后dfs；



但如果不加记忆化搜索优化 !(logn) 的时间复杂度会使 二进制中 1 比较多的数 萎掉
所以我们需要一个记忆化搜索 mem[i][j] 表示以2^i为结尾，剩余数最低位为2^j 的方案数；


